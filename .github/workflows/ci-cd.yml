# This workflow automates the CI/CD pipeline for Spring PetClinic:
# 1. Compiles and Tests the application (Java 21, skipping Java 25+ check).
# 2. Packages the application into a Docker image (using Temurin).
# 3. Pushes the image to JFrog Artifactory.
# 4. Publishes build info and runs an Xray security scan (gating the pipeline).
name: PetClinic CI/CD to JFrog

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering

env:
  # This block is only for non-sensitive, static variables
  DOCKER_REPO_KEY: "petclinic-docker-local" # The name of your Artifactory Docker local/virtual repo
  IMAGE_NAME: "spring-petclinic"
  BUILD_NAME: "petclinic-docker-build"

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- 1. COMPILE AND RUN TESTS (Original Task Steps 1 & 2) ---
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21' # Using stable LTS 21
          distribution: 'temurin'
          cache: 'maven' # Caches Maven dependencies

      - name: Ensure Maven Wrapper is Executable
        run: chmod +x mvnw

      - name: Compile and Test with Maven
        # CRITICAL FIX: The skip flag is mandatory because the project requires Java 25, 
        # but we are using Java 21 for stability.
        run: ./mvnw clean install -Dmaven.enforcer.skip=true

      # --- 2. SETUP JFROG CLI & CONFIGURE DOCKER LOGIN (FINAL FIX HERE) ---
      - name: Setup JFrog CLI and Configure Server
        uses: jfrog/setup-jfrog-cli@v4
        with:
          # PASS SECRETS DIRECTLY: This bypasses the intermediate env variable step
          url: ${{ secrets.JFROG_PLATFORM_URL }} # <-- DIRECT ACCESS TO SECRET
          access-token: ${{ secrets.JFROG_ACCESS_TOKEN }}
          username: ${{ secrets.JFROG_USERNAME }}
          # The configuration is stored under the default server ID.
          
      # Retrieve project version from pom.xml for dynamic tagging
      - name: Extract Project Version
        id: version
        run: echo "PROJECT_VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout)" >> $GITHUB_OUTPUT

      - name: Set Image Tag and Full Path
        id: tagging
        run: |
          # 1. FIX: Strip both the protocol (https://) AND the trailing slash (/$).
          # This guarantees a clean REGISTRY_HOST for concatenation.
          REGISTRY_HOST=$(echo ${{ secrets.JFROG_PLATFORM_URL }} | sed -e 's|^https://||' -e 's|/$||')
          
          # 2. Define the TAG using the project version and short commit SHA
          SHORT_SHA=${{ github.sha }}
          TAG=${{ steps.version.outputs.PROJECT_VERSION }}-${SHORT_SHA::7}
          
          # 3. Construct the FULL_IMAGE_NAME using only the REGISTRY_HOST (no protocol)
          FULL_IMAGE_NAME=${REGISTRY_HOST}/${{ env.DOCKER_REPO_KEY }}/${{ env.IMAGE_NAME }}:${TAG}
          
          echo "IMAGE_TAG=$TAG" >> $GITHUB_OUTPUT
          echo "FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "BUILD_NUMBER=$TAG" >> $GITHUB_ENV # Set build number for Artifactory Build Info

      - name: Docker Login to Artifactory Registry
        run: |
          # The domain of the Artifactory registry is the platform URL hostname (protocol stripped).
          # This sed command is updated to match the one used for tagging.
          REGISTRY_HOST=$(echo ${{ secrets.JFROG_PLATFORM_URL }} | sed -e 's|^https://||' -e 's|/$||')
          echo "Logging into $REGISTRY_HOST"
          # Use JFrog credentials (username and access token as password) for Docker login
          echo "${{ secrets.JFROG_ACCESS_TOKEN }}" | docker login $REGISTRY_HOST -u ${{ secrets.JFROG_USERNAME }} --password-stdin

      # --- 3. PACKAGE AND PUBLISH DOCKER IMAGE (Original Task Steps 4 & 5) ---
      - name: Docker Build and Tag
        run: |
          # Uses the FULL_IMAGE_NAME variable which now contains the correct registry hostname
          docker build -t ${{ steps.tagging.outputs.FULL_IMAGE_NAME }} .

      - name: Docker Push to Artifactory and Collect Build-Info
        run: |
          # Use JFrog CLI command 'jf docker push' to collect build-info automatically
          jf docker push ${{ steps.tagging.outputs.FULL_IMAGE_NAME }} ${{ env.DOCKER_REPO_KEY }} \
             --build-name=${{ env.BUILD_NAME }} \
             --build-number=${{ env.BUILD_NUMBER }}

      - name: Publish Build Info to Artifactory
        run: jf build publish ${{ env.BUILD_NAME }} ${{ env.BUILD_NUMBER }}

      # --- 4. XRAY SCAN (Required Deliverable) ---
      - name: Xray Scan Build
        # Triggers a scan on the build published in the previous step
        run: jf bs ${{ env.BUILD_NAME }} ${{ env.BUILD_NUMBER }}

      - name: Xray Wait For Scan Results and Fail on Violations
        # Waits for the scan to finish and fails the job if any policy violations are found.
        # This is crucial for pipeline gating.
        run: jf build scan ${{ env.BUILD_NAME }} ${{ env.BUILD_NUMBER }} --wait

      - name: Print Final Image Path
        run: |
          echo "Successfully pushed image: ${{ steps.tagging.outputs.FULL_IMAGE_NAME }}"
